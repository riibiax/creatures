<html>
    <head>
        <title>Characters</title>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <meta charset="utf-8">
        <style>
            * {
                box-sizing: border-box;
                -moz-box-sizing: border-box;
            }

            body {
                color: #000;
                font-family:Monospace;
                font-size:13px;

                background-color: #fff;
                margin: 0px;
            }

            #info {
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;
                text-align:center;
            }

            #content {
                position: absolute;
                top: 0px; width: 100%;
                z-index: 1;
                padding: 3em 0 0 0;
            }

            #submit {
                position: fixed;
                top: 0;
                right: 0;
            }

            #c {
                position: fixed;
                left: 0px;
                width: 100%;
                height: 100%;
            }

            .list-item {
                display: inline-block;
                margin: 1em;
                padding: 1em;
                box-shadow: 1px 2px 4px 0px rgba(0,0,0,0.25);
            }

            .list-item .scene {
                width: 200px;
                height: 200px;
            }

            .list-item .description {
                color: #888;
                font-family: sans-serif;
                font-size: large;
                width: 200px;
                margin-top: 0.5em;
            }
        </style>
    </head>
    <body>

        <input type="submit" value="submit" onclick="return foo();" />
        <canvas id="c"></canvas>

        <div id="content">
        </div>
        <script src="https://cdn.socket.io/socket.io-1.4.5.js"></script>

        <script src="src/js/three.min.js"></script>
        <script src="src/js/Detector.min.js"></script>
        <script src="src/js/OrbitControls.js"></script>
        <script src="src/js/stats.min.js"></script>

        <script id="vertexRawShader" type="x-shader/x-vertex">
            precision mediump float;
            precision mediump int;
            uniform mat4 modelViewMatrix; // optional
            uniform mat4 projectionMatrix; // optional
            attribute vec3 position;
            attribute vec4 color;
            varying vec3 vPosition;
            varying vec4 vColor;
            void main() {
                vPosition = position;
                vColor = color;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }
        </script>

        <script id="fragmentRawShader" type="x-shader/x-fragment">
            precision mediump float;
            precision mediump int;
            uniform float time;
            varying vec3 vPosition;
            varying vec4 vColor;
            void main() {
                vec4 color = vec4( vColor );
                color.r += sin( vPosition.x * 10.0 + time ) * 0.5;
                gl_FragColor = color;
            }
        </script>
        
        <script type="x-shader/x-vertex" id="vertexParticleShader">
            uniform float amplitude;
            uniform float direction;
            uniform vec3 light;
            uniform float time;
            uniform float lightDistance;
            uniform float noiseFactor;
            attribute float size;
            attribute vec3 customPosition;
            varying vec3 vPosition;
            varying vec3 lightColor;

            void main() {

                vPosition = position;

                // small noise  movement==> è il formicolio che si vede nel disegno==> meno noise è + chiaro è il disegn
                vPosition.x += cos(time + (position.y/8.0))*noiseFactor; 
                vPosition.z += sin(time + (position.x/8.0))*noiseFactor; 
                vPosition.y += sin(time + (position.z/4.0))*noiseFactor;

                // morph
                vec3 morphed = vec3( 0.0, 0.0, 0.0 );
                morphed += ( customPosition - position ) * amplitude;
                morphed += vPosition;

                vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );


                //grandezza delle particelle
                gl_PointSize = min(50.0, size * ( 50.0 / length( mvPosition.xyz ) ) );

                gl_Position = projectionMatrix * mvPosition;

                // light
                vec3 transformedNormal = normalize(mvPosition.xyz);

                //quanto è nera la zona d'ombra. più il valore è basso e + la zona di luce è illuminata e l'altra buia
                lightColor = vec3(0.025,0.025,0.025);

                vec4 lPosition = viewMatrix * vec4( light, 1.0 );
                vec3 lVector = lPosition.xyz - mvPosition.xyz;

                float lDistance = 1.0;
                lDistance = 1.0 - min( ( length( lVector ) / lightDistance ), 1.0 );

                lightColor += vec3(1.0,1.0,1.0) * lDistance;
                lightColor *= 4.0;
            }

        </script>

        <script type="x-shader/x-fragment" id="fragmentParticleShader">
            #define MOD3 vec3(443.8975,397.2973, 491.1871)
            const float UPDATE_RATE = 30.0;
            const float MINIMUM_LIGHT_INTENSITY = 0.75;
            const float MAXIMUM_LIGHT_INTENSITY = 2.75;
            const float LIGHT_INTENSITY_RANDOMNESS = 0.3;
            const float MAXIMUM_LIGHT = MINIMUM_LIGHT_INTENSITY + 2.0 * MAXIMUM_LIGHT_INTENSITY + LIGHT_INTENSITY_RANDOMNESS;
            uniform int lightSwitch;
            uniform sampler2D texture;
            uniform int activateFlickering;
            uniform float time;
            varying vec3 lightColor;
            uniform float lightDistance;
            float hash11(float p)
            {
                vec3 p3  = fract(vec3(p) * MOD3);
                p3 += dot(p3, p3.yzx + 19.19);
                return fract(p3.x * p3.y * p3.z);
            }

            void main() {
                float depth = gl_FragCoord.z / gl_FragCoord.w;
                float depthcolor = 1.0 - smoothstep( 0.0, lightDistance, depth );

                vec4 outColor = texture2D( texture, gl_PointCoord );
                if ( outColor.a < 0.5 ) discard; // alpha be gone, più è basso è meno si vede l'alpha ma diventa però giallo. più è alto e più si vede l'alpha==> moche
                if(activateFlickering==1)
                {
                    float t = time;
                    t *= UPDATE_RATE;
                    t -= fract(t);
                    t /= UPDATE_RATE;
                    float intensity = (MINIMUM_LIGHT_INTENSITY + (MAXIMUM_LIGHT_INTENSITY + (sin(t) * MAXIMUM_LIGHT_INTENSITY)));
                    intensity += LIGHT_INTENSITY_RANDOMNESS + (hash11(t) * 2.0) - 1.0;
                    intensity /= MAXIMUM_LIGHT;
                    intensity +=0.1;
                    intensity = clamp(intensity, 0.4, 1.0);
                    gl_FragColor = vec4( outColor.xyz * intensity, outColor.a);
                }
                else
                {
                    if (lightSwitch != 0) {
                        gl_FragColor = vec4( outColor.xyz * lightColor * depthcolor, outColor.a);
                    }
                    else {
                        gl_FragColor = outColor;
                    }
                }


            }
        </script>


        <script id="template" type="notjs">
            <div class="scene"></div>
            <div class="description">Creature $</div>
        </script>

        <script>
            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
            var frameLimit=90;
            var currentFrame=0;

            var canvas, content;

            var scenes = [], renderer;

            var stats;

            var verticesBufferGeometry;
            var textures = {};
            var baseSize;
            var visualisation = {
                standardMaterial :  false,
                rawShader: true,
                particlesMaterial: false
            } 
            createTextures();
            init();

            function init() {
                canvas = document.getElementById( "c" );                
                content = document.getElementById( "content" );
                
                socketInit();

                var submit = document.createElement( "INPUT" );
                submit.setAttribute("id", "submit"); 
                submit.setAttribute("type", "submit"); 
                submit.setAttribute("onclick", "sendLocation();"); 
                content.appendChild( submit );

                addStats();
            }

            function initSketch(numberInstances) {
                var template = document.getElementById( "template" ).text;
                var i;
                
                for (i =  0; i < numberInstances; i ++) {

                    verticesBufferGeometry = [];
                    var scene = new THREE.Scene();

                    // make a list item
                    var element = document.createElement( "div" );
                    element.className = "list-item";
                    element.innerHTML = template.replace( '$', i + 1 );

                    // Look up the element that represents the area
                    // we want to render the scene
                    scene.userData.element = element.querySelector( ".scene" );
                    content.appendChild( element );

                    var camera = new THREE.PerspectiveCamera( 50, 1, 1, 20 );
                    camera.position.z = 10;
                    scene.userData.camera = camera;

                    var controls = new THREE.OrbitControls( scene.userData.camera, scene.userData.element );
                    controls.minDistance = 1;
                    controls.maxDistance = 15;
                    controls.enablePan = false;
                    controls.enableZoom = true;
                    scene.userData.controls = controls;

                    // add one random mesh to each scene

                   
                    var geometry = creatingCreature();
                    var creatureMesh;
                    if(visualisation.rawShader || visualisation.particlesMaterial){
                        var bufferGeometry = new THREE.BufferGeometry();
                    }
                    if(visualisation.standardMaterial)
                    {
                        var standardMaterial = new THREE.MeshStandardMaterial( {
                            color: new THREE.Color().setHSL( Math.random(), 1, 0.75 ),
                            roughness: 0.5,
                            metalness: 0,
                            shading: THREE.FlatShading,
                            //wireframe: true
                        } );
                        creatureMesh = new THREE.Mesh(geometry, standardMaterial);

                    } 
                    else if(visualisation.rawShader)
                    {
                        bufferGeometry.addAttribute( 'position', new THREE.BufferAttribute( verticesBufferGeometry, 3 ) );
                        var bufferGeometrySize = Math.floor(verticesBufferGeometry.length/3);
                        var colors = new Uint8Array( bufferGeometrySize * 4 );
                        for ( var n = 0, l = bufferGeometrySize * 4; n < l; n += 4 ) {
                            colors[ n     ] = Math.random() * 255;
                            colors[ n + 1 ] = Math.random() * 255;
                            colors[ n + 2 ] = Math.random() * 255;
                            colors[ n + 3 ] = Math.random() * 255;
                        }

                        bufferGeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 4, true ) );

                        var rawShaderMaterial = new THREE.RawShaderMaterial( {
                            uniforms: {
                                time: { value: 1.0 }
                            },
                            vertexShader: document.getElementById( 'vertexRawShader' ).textContent,
                            fragmentShader: document.getElementById( 'fragmentRawShader' ).textContent,
                            side: THREE.DoubleSide,
                            transparent: true
                        } );
                        creatureMesh = new THREE.Mesh(bufferGeometry,rawShaderMaterial);
                    }
                    else if(visualisation.particlesMaterial)
                    {
                        var uniformsParticles = {
                            amplitude: { type: "f", value: 1.0 },
                            texture:   { type: "t", value: textures.map },
                            time:      { type: "f", value: 0.1 },
                            direction: { type: "f", value: 1.0 },
                            lightSwitch: { type: "i", value: 0 },
                            light:     { type: "v3", value: new THREE.Vector3() },
                            lightDistance: { type: "f", value: 5000.0 },
                            activateFlickering:{ type: "i", value: 0 } ,
                            noiseFactor: { type: "f", value: 0.1 } ,
                        };

                        var shaderMaterialParticles = new THREE.ShaderMaterial( {
                            uniforms:       uniformsParticles,
                            vertexShader:   document.getElementById( 'vertexParticleShader' ).textContent,
                            fragmentShader: document.getElementById( 'fragmentParticleShader' ).textContent,
                            blending:       THREE.AdditiveBlending,
                            depthTest:      false,
                            transparent:    true
                        });

                        var geometrySize = geometry.vertices.length;
                        var geometryVertices = geometry.vertices;
                        var sizes = new Float32Array( geometrySize );
                        var customPosition = new Float32Array( geometrySize * 3 );
                        var positions = new Float32Array( geometrySize * 3 );
                        baseSize = []; 
                        var indexParticles;
                        for (var v = 0, i3 = 0; v < geometrySize; v ++, i3 += 3) 
                        {
                            var vector = getRandomPointOnparticles(1+Math.random()*1.5);
                            positions[ i3 + 0 ] = vector.x;
                            positions[ i3 + 1 ] = vector.y;
                            positions[ i3 + 2 ] = vector.z;
                        } 

                        for( var v = 0; v < geometrySize; v++ ) 
                        {
                            indexParticles= v * 3;
                            baseSize[v] = 1+Math.random()*3;
                            sizes[v] = baseSize[v];
                            customPosition[ indexParticles     ] = geometryVertices[ v ].x;
                            customPosition[ indexParticles + 1 ] = geometryVertices[ v ].y;
                            customPosition[ indexParticles + 2 ] = geometryVertices[ v ].z;
                        }
                        bufferGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ));
                        bufferGeometry.addAttribute( 'size', new THREE.BufferAttribute(sizes,1).setDynamic(true));
                        bufferGeometry.addAttribute( 'customPosition', new THREE.BufferAttribute( customPosition, 3 ).setDynamic(true));

                        creatureMesh = new THREE.Points( bufferGeometry, shaderMaterialParticles );
                        creatureMesh.geometry.attributes.customPosition.needsUpdate = true;
                    }

                    creatureMesh.name = "creature";
                    scene.add( creatureMesh );
                    scene.add( new THREE.HemisphereLight( 0xaaaaaa, 0x444444 ) );

                    var light = new THREE.DirectionalLight( 0xffffff, 0.5 );
                    light.position.set( 1, 1, 1 );
                    scene.add( light );

                    scenes.push( scene );
                }

                renderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true } );
                renderer.setClearColor( 0xffffff, 1 );
                renderer.setPixelRatio( window.devicePixelRatio );

                animate();
            }


            function createTextures() {
                textures.map = new THREE.TextureLoader().load("img/spark1.png");
            }


            function getRandom(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }


            function getRandomArbitrary(min, max) {
                return Math.random() * (max - min) + min;
            }


            function getRandomPointOnparticles(r) {
                var angle = Math.random() * Math.PI * 2;
                var u = Math.random() * 2 - 1;  
                var v = new THREE.Vector3(
                    Math.cos(angle) * Math.sqrt(1 - Math.pow(u, 2)) * r,
                    Math.sin(angle) * Math.sqrt(1 - Math.pow(u, 2)) * r,
                    u * r
                );
                return v;
            }


            function Float32Concat(first, second) {
                var firstLength = first.length;
                var result = new Float32Array(firstLength + second.length);
                result.set(first);
                result.set(second, firstLength);
                return result;
            }

            function addToBufferGeometry(geom) {
                if(visualisation.rawShader){
                    var verticesGeometry = geom.vertices;

                    var verticesGeometrySize= geom.vertices.length;
                    
                    var vertices = new Float32Array( verticesGeometrySize * 3 * 3);
                    var n;
                    var f;
                    var randomIndex;
                    for (n = 0, f=0; f < verticesGeometrySize; n += 3) {
                        
                        if(n % 9 == 0 )
                        {
                            vertices[ n     ] = verticesGeometry[ f ].x;
                            vertices[ n + 1 ] = verticesGeometry[ f ].y;
                            vertices[ n + 2 ] = verticesGeometry[ f ].z;
                            f++;
                        }
                        else
                        {
                            randomIndex = getRandom(0, verticesGeometrySize-1);
                            vertices[ n     ] = verticesGeometry[ randomIndex ].x * (Math.random() * .3 + 1);
                            vertices[ n + 1 ] = verticesGeometry[ randomIndex ].y * (Math.random() * .3 + 1);
                            vertices[ n + 2 ] = verticesGeometry[ randomIndex ].z * (Math.random() * .3 + 1);
                        }
                    }
                    verticesBufferGeometry = Float32Concat(verticesBufferGeometry, vertices);
                }
            }


            function creatingCreature() {
                var offset = new THREE.Vector2();

                var creatureGeometry = creatingNose(offset);
                creatureGeometry.computeBoundingBox();
                creatureGeometry.computeBoundingSphere();
                offset.x = creatureGeometry.boundingBox.max.x;
                offset.y = creatureGeometry.boundingBox.max.y * 1.5 - creatureGeometry.boundingSphere.center.y;
                var offsetYMouth = -creatureGeometry.boundingBox.max.y + creatureGeometry.boundingSphere.center.y*2.;

                var eyesGeometry = creatingEyes(offset);
                
                creatureGeometry.merge(eyesGeometry);
                creatureGeometry.computeBoundingBox();
                offset.x = creatureGeometry.boundingBox.max.x;
                offset.y = creatureGeometry.boundingBox.max.y;

                var earsGeometry = creatingEars(offset);
                creatureGeometry.merge(earsGeometry);

                offset.y =  offsetYMouth;
                var mouthGeometry = creatingMouth(offset);
                creatureGeometry.merge(mouthGeometry);

                creatureGeometry.computeFaceNormals();
                creatureGeometry.computeVertexNormals();
                return creatureGeometry;
            }


            function creatingNose(offset) {
                var coneUpDown = new THREE.ConeGeometry(1., 1., 3, 15);
                coneUpDown.computeBoundingBox();
                coneUpDown.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI));
                coneUpDown.applyMatrix(new THREE.Matrix4().makeTranslation(0, -coneUpDown.boundingBox.max.y * .5, 0));                
                var coneDownUp = new THREE.ConeGeometry(1., 1., 3, 15);
                coneDownUp.computeBoundingBox();
                coneDownUp.applyMatrix(new THREE.Matrix4().makeTranslation(0, coneDownUp.boundingBox.max.y, 0)); 
                var box = new THREE.BoxGeometry(.75, .75, .75, 5, 5, 5);
                box.computeBoundingBox();
                box.applyMatrix(new THREE.Matrix4().makeTranslation(0, -box.boundingBox.max.y * .75, 0));
                var sphere = new THREE.SphereGeometry(.5, 12, 12);
                sphere.computeBoundingBox();
                sphere.applyMatrix(new THREE.Matrix4().makeTranslation(0, sphere.boundingBox.max.y * .5, 0));
                var cylinder =  new THREE.CylinderGeometry(.5, .5, 1.25, 12, 10);
                var noseGeometries = [
                    coneUpDown,
                    coneDownUp,
                    box,
                    sphere,
                    cylinder
                ];
                var index = getRandom (0, noseGeometries.length-1);
                var noseGeometry = noseGeometries [index | 0];
                addToBufferGeometry(noseGeometry);
                return noseGeometry;
            }


            function creatingEyes(offset) {
                var coneUpDown = new THREE.ConeGeometry( .5, .5, 3, 15);
                coneUpDown.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI));
                var coneDownUp = new THREE.ConeGeometry( .5, .5, 3, 15);
                var box = new THREE.BoxGeometry(.5, .5, .5, 5, 5, 5);
                var sphere = new THREE.SphereGeometry( .25, 12, 12);
                var cylinderVertical =  new THREE.CylinderGeometry( .25, .25, .5, 12, 10);
                var cylinderHorizontal = new THREE.CylinderGeometry( .25, .25, .5, 12, 10);
                cylinderHorizontal.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI / 2.));
                var torus = new THREE.TorusGeometry( .25, .1, 16, 20);
                torus.computeBoundingBox();
                torus.applyMatrix(new THREE.Matrix4().makeTranslation(.0, -torus.boundingBox.max.y * .25, 0));
                var torusUp = new THREE.TorusGeometry( .25, .1, 16, 20, Math.PI );
                torusUp.computeBoundingBox();
                torusUp.applyMatrix(new THREE.Matrix4().makeTranslation(.0, -torusUp.boundingBox.max.y * .5, 0));
                var torusDown = new THREE.TorusGeometry( .25, .1, 16, 20, -Math.PI );
                torusDown.applyMatrix(new THREE.Matrix4().makeTranslation(.0, torusUp.boundingBox.max.y , 0));
                var torusHorizontal = new THREE.TorusGeometry( .25, .1, 16, 20);
                torusHorizontal.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), Math.PI/2));  

                var eyesGeometries = [
                    coneUpDown,
                    coneDownUp,
                    box,
                    sphere,
                    cylinderVertical,
                    cylinderHorizontal,
                    torus,
                    torusUp,
                    torusDown,
                    torusHorizontal
                ];
                var index = getRandom (0, eyesGeometries.length-1);
                var eyesGeometry = eyesGeometries[ index | 0 ];
                eyesGeometry.computeBoundingBox();
                var eyesGeometrySpecular = eyesGeometry.clone();
                eyesGeometrySpecular.computeBoundingBox();

                eyesGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(offset.x + eyesGeometry.boundingBox.max.x * .5, offset.y + eyesGeometry.boundingBox.max.y * 2., 0));

                eyesGeometrySpecular.applyMatrix(new THREE.Matrix4().makeTranslation(-offset.x - eyesGeometrySpecular.boundingBox.max.x * .5, offset.y +  eyesGeometrySpecular.boundingBox.max.y * 2., 0));
                addToBufferGeometry(eyesGeometry);
                addToBufferGeometry(eyesGeometrySpecular);
                eyesGeometry.merge(eyesGeometrySpecular);
                return eyesGeometry;
            }


            function creatingEars(offset) {
                var rotatedConeUp = new THREE.ConeGeometry(.25, 1.5, 4, 15);
                rotatedConeUp.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), -Math.PI / 8.));

                var rotatedConeDown =  new THREE.ConeGeometry(.25, 2., 4, 15);
                rotatedConeDown.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), -Math.PI / 4. * 3.));
                rotatedConeDown.computeBoundingBox();
                rotatedConeDown.applyMatrix(new THREE.Matrix4().makeTranslation(0, -rotatedConeDown.boundingBox.max.y, 0));

                var box = new THREE.BoxGeometry(.25, .25, .25, 5, 5, 5);
                box.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI / 4.)); 

                var sphere = new THREE.SphereGeometry(.25, 12, 12);

                var cylinderUp = new THREE.CylinderGeometry(.125, .125, .75, 12, 10);
                cylinderUp.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), -Math.PI / 8.));

                var cylinderDown = new THREE.CylinderGeometry(.125, .125, 1., 12, 10);
                cylinderDown.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), -Math.PI / 4. * 3.));
                cylinderDown.computeBoundingBox();
                cylinderDown.applyMatrix(new THREE.Matrix4().makeTranslation(0, -cylinderDown.boundingBox.max.y, 0));

                var earsGeometries = [
                    rotatedConeUp,
                    rotatedConeDown,
                    box,
                    sphere,
                    cylinderUp,
                    cylinderDown
                ];
                var index = getRandom (0, earsGeometries.length-1);
                var earsGeometry = earsGeometries[ index | 0 ];
                earsGeometry.computeBoundingBox();
                var earsGeometrySpecular = earsGeometry.clone();
                earsGeometrySpecular.computeBoundingBox();

                earsGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(offset.x + earsGeometry.boundingBox.max.x*1.5, offset.y + earsGeometry.boundingBox.max.y, 0));
                if(index == 0 || index == 4){
                    earsGeometrySpecular.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI / 4.)); 
                    earsGeometrySpecular.applyMatrix(new THREE.Matrix4().makeTranslation(-offset.x - earsGeometrySpecular.boundingBox.max.x*1.5, offset.y +  earsGeometrySpecular.boundingBox.max.y, 0));
                }
                else if(index == 1 || index == 5){
                    earsGeometrySpecular.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI / 2. * 3)); 
                    earsGeometrySpecular.applyMatrix(new THREE.Matrix4().makeTranslation(-offset.x - earsGeometrySpecular.boundingBox.max.x*1.5, offset.y -earsGeometrySpecular.boundingBox.max.y, 0));
                }
                else if(index == 2 || index == 3){
                    earsGeometrySpecular.applyMatrix(new THREE.Matrix4().makeTranslation(-offset.x - earsGeometrySpecular.boundingBox.max.x*1.5, offset.y +earsGeometrySpecular.boundingBox.max.y, 0));
                }
                else{
                    earsGeometrySpecular.applyMatrix(new THREE.Matrix4().makeTranslation(-offset.x - earsGeometrySpecular.boundingBox.max.x*1.5, offset.y +earsGeometrySpecular.boundingBox.max.y, 0));
                }
                addToBufferGeometry(earsGeometry);
                addToBufferGeometry(earsGeometrySpecular);
                earsGeometry.merge(earsGeometrySpecular);
                return earsGeometry;
            }


            function creatingMouth(offset) {
                var coneUpDown = new THREE.ConeGeometry(2., 1., 25, 10);
                coneUpDown.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI));              
                var coneDownUp = new THREE.ConeGeometry(2.25, 1.25, 25, 10);
                var box = new THREE.BoxGeometry(2.5, 1., 2.5, 10, 10, 10);
                box.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), Math.PI/4));
                var sphere = new THREE.SphereGeometry(1.25, 12, 12);

                var circle = new THREE.CircleGeometry( 1.5, 32 );
                circle.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), Math.PI));
                var halfSphere = new THREE.SphereGeometry(1.5, 12, 12, 0, Math.PI);
                halfSphere.merge(circle);
                halfSphere.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2.));
                halfSphere.computeFaceNormals();
                halfSphere.computeVertexNormals();

                var cylinder =  new THREE.CylinderGeometry(.25, .25, 3., 12, 10);
                cylinder.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI / 2.));

                var torusVertical = new THREE.TorusGeometry( 1., .15, 16, 20);

                var torusHorizontal = new THREE.TorusGeometry( 1.5, .25, 16, 20);
                torusHorizontal.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), Math.PI/2));  

                var mouthGeometries = [
                    coneUpDown,
                    coneDownUp,
                    box,
                    sphere,
                    halfSphere,
                    cylinder,
                    torusVertical, 
                    torusHorizontal
                ];
                var index = getRandom (0, mouthGeometries.length-1);
                var mouthGeometry = mouthGeometries[ index | 0 ];
                mouthGeometry.computeBoundingBox();
                if(index == 0){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.y * 3.5, 0));
                }
                else if (index == 1){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.y * 2.5, 0));
                }
                else if (index == 2){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.y * 3.5, 0));
                }
                else if (index == 3){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.y * 1.5, 0));
                }
                else if (index == 4){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.x * .5, 0));
                }
                else if (index == 5){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.y * 6., 0));
                }
                else if(index == 6){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.x * 1.5, 0));
                }
                else if(index == 7){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.x * .75, 0));
                }
                addToBufferGeometry(mouthGeometry);
                return mouthGeometry;
            }


            function addStats() {
                stats = new Stats();
                document.getElementById( "content" ).appendChild( stats.dom );
            }


            function sendLocation() {
                var position = navigator.geolocation;
                var sendingData = 
                {
                    "latitude":     0,
                    "longitude":    0,
                    "altitude":     0
                };
                if (position) {
                    position.getCurrentPosition(setPosition, getErrLocation);
                    function setPosition(position) {
                        sendingData.latitude = position.coords.latitude;
                        sendingData.longitude = position.coords.longitude;
                        sendingData.altitude = position.coords.altitude;
                        sendingLocation();
                    }
                }
                else {
                    //Geolocation is not supported by this browser.
                    getErrLocation();
                }

                function getErrLocation() {
                    sendingData.latitude = getRandomArbitrary(-90.0,90.0);
                    sendingData.longitude = getRandomArbitrary(-180.0,180.0);
                    sendingData.altitude = getRandom(0,6000);
                    sendingLocation();
                }

                function sendingLocation() {
                    console.log("Sending location");
                    console.log(sendingData);
                    socket.emit("pushingData", sendingData);
                }
            }


            function submitData() {
                var sendingCreatures = 10;
                currentFrame=1;
                //socket.emit("broadcastData", sendingCreatures);
                //socket.emit("tweetData", sendingCreatures);
            }


            function socketInit() {
                socket = io.connect('http://localhost:3000');
                socket.on('broadcastData', refreshCreatures);
                //Initialize instances
                socket.on("initializeClient", initializeClient);
                socket.emit("initializeClient");
            }


            function refreshCreatures(data) {
                //todo refresh my creatures
                console.log("Receiving Data: " + data);
            }


            function initializeClient(data) {
                console.log("Initializing instances: " + data);
                initSketch(data);
            }


            function sendFrame() {
                socket.emit('render-frame', {
                        frame: currentFrame,
                        file: document.querySelector('canvas').toDataURL()
                });
            }


            function updateSize() {
                var width = canvas.clientWidth;
                var height = canvas.clientHeight;
                if ( canvas.width !== width || canvas.height != height ) 
                {
                    renderer.setSize( width, height, false );
                }
            }

            function animate() {
                render();
                stats.update();
                requestAnimationFrame( animate );
            }

            function render() {
                var time = performance.now();
                updateSize();

                renderer.setClearColor( 0xffffff );
                renderer.setScissorTest( false );
                renderer.clear();

                renderer.setClearColor( 0xe0e0e0 );
                renderer.setScissorTest( true );
                scenes.forEach( function( scene ) {

                    // so something moves
                    var object = scene.children[ 0 ];
                    object.rotation.y = Date.now() * 0.0005;
                    if(object.material.uniforms) {
                        object.material.uniforms.time.value = time * 0.005;
                    }

                    // get the element that is a place holder for where we want to
                    // draw the scene
                    var element = scene.userData.element;

                    // get its position relative to the page's viewport
                    var rect = element.getBoundingClientRect();

                    // check if it's offscreen. If so skip it
                    if ( rect.bottom < 0 || rect.top  > renderer.domElement.clientHeight ||
                         rect.right  < 0 || rect.left > renderer.domElement.clientWidth ) {

                        return;  // it's off screen

                    }

                    // set the viewport
                    var width  = rect.right - rect.left;
                    var height = rect.bottom - rect.top;
                    var left   = rect.left;
                    var bottom = renderer.domElement.clientHeight - rect.bottom;

                    renderer.setViewport( left, bottom, width, height );
                    renderer.setScissor( left, bottom, width, height );

                    var camera = scene.userData.camera;

                    //camera.aspect = width / height; // not changing in this example
                    //camera.updateProjectionMatrix();

                    //scene.userData.controls.update();



                    renderer.render( scene, camera );


                } );

                if( currentFrame>=1 && currentFrame<=frameLimit ) {
                    sendFrame();
                    currentFrame++;
                }
            }

        </script>
    </body>
</html>