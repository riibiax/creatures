<html>
    <head>
        <title>Characters</title>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <meta charset="utf-8">
        <style>
            * {
                box-sizing: border-box;
                -moz-box-sizing: border-box;
            }

            body {
                color: #000;
                font-family:Monospace;
                font-size:13px;

                background-color: #fff;
                margin: 0px;
            }

            #info {
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;
                text-align:center;
            }

            #content {
                position: absolute;
                top: 0px; width: 100%;
                z-index: 1;
                padding: 3em 0 0 0;
            }

            #submit {
                position: fixed;
                top: 0;
                right: 0;
            }

            #c {
                position: fixed;
                left: 0px;
                width: 100%;
                height: 100%;
            }

            .list-item {
                display: inline-block;
                margin: 1em;
                padding: 1em;
                box-shadow: 1px 2px 4px 0px rgba(0,0,0,0.25);
            }

            .list-item .scene {
                width: 200px;
                height: 200px;
            }

            .list-item .description {
                color: #888;
                font-family: sans-serif;
                font-size: large;
                width: 200px;
                margin-top: 0.5em;
            }
        </style>
    </head>
    <body>

        <input type="submit" value="submit" onclick="return foo();" />
        <canvas id="c"></canvas>

        <div id="content">
        </div>
        <script src="https://cdn.socket.io/socket.io-1.4.5.js"></script>

        <script src="src/js/three.min.js"></script>
        <script src="src/js/Detector.min.js"></script>
        <script src="src/js/OrbitControls.js"></script>
        <script src="src/js/stats.min.js"></script>

        <script id="template" type="notjs">
            <div class="scene"></div>
            <div class="description">Creature $</div>
        </script>

        <script>
            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
            var frameLimit=90;
            var currentFrame=0;

            var canvas, content;

            var scenes = [], renderer;

            var stats;
            
            init();

            function init() {
                canvas = document.getElementById( "c" );                
                content = document.getElementById( "content" );
                
                socketInit();

                var submit = document.createElement( "INPUT" );
                submit.setAttribute("id", "submit"); 
                submit.setAttribute("type", "submit"); 
                submit.setAttribute("onclick", "sendLocation();"); 
                content.appendChild( submit );

                addStats();
            }

            function initSketch(numberInstances) {
                var template = document.getElementById( "template" ).text;

                for ( var i =  0; i < numberInstances; i ++ ) {


                    var scene = new THREE.Scene();

                    // make a list item
                    var element = document.createElement( "div" );
                    element.className = "list-item";
                    element.innerHTML = template.replace( '$', i + 1 );

                    // Look up the element that represents the area
                    // we want to render the scene
                    scene.userData.element = element.querySelector( ".scene" );
                    content.appendChild( element );

                    var camera = new THREE.PerspectiveCamera( 50, 1, 1, 20 );
                    camera.position.z = 10;
                    scene.userData.camera = camera;

                    var controls = new THREE.OrbitControls( scene.userData.camera, scene.userData.element );
                    controls.minDistance = 1;
                    controls.maxDistance = 15;
                    controls.enablePan = false;
                    controls.enableZoom = true;
                    scene.userData.controls = controls;

                    // add one random mesh to each scene
                   // var geometry = getRandomGeometry();

                    var geometry = creatingCreature();
                    

                    var material = new THREE.MeshPhongMaterial( {

                        color: new THREE.Color().setHSL( Math.random(), 1, 0.75 ),
                        roughness: 0.5,
                        metalness: 0,
                        shading: THREE.FlatShading

                    } );
                    var creatureMesh = new THREE.Mesh( geometry, material );
                    creatureMesh.name="creature";
                    scene.add( creatureMesh );

                    scene.add( new THREE.HemisphereLight( 0xaaaaaa, 0x444444 ) );

                    var light = new THREE.DirectionalLight( 0xffffff, 0.5 );
                    light.position.set( 1, 1, 1 );
                    scene.add( light );

                    scenes.push( scene );

                }

                renderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true } );
                renderer.setClearColor( 0xffffff, 1 );
                renderer.setPixelRatio( window.devicePixelRatio );

                animate();
            }

            function getRandom(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            function getRandomArbitrary(min, max) {
                return Math.random() * (max - min) + min;
            }


            function creatingCreature() {
                var offset = new THREE.Vector2();

                var creatureGeometry = creatingNose(offset);
                creatureGeometry.computeBoundingBox();
                creatureGeometry.computeBoundingSphere();
                offset.x = creatureGeometry.boundingBox.max.x;
                offset.y = creatureGeometry.boundingBox.max.y * 1.5 - creatureGeometry.boundingSphere.center.y;
                var offsetYMouth = -creatureGeometry.boundingBox.max.y + creatureGeometry.boundingSphere.center.y*2.;

                var eyesGeometry = creatingEyes(offset);
                creatureGeometry.merge(eyesGeometry);
                creatureGeometry.computeBoundingBox();
                offset.x = creatureGeometry.boundingBox.max.x;
                offset.y = creatureGeometry.boundingBox.max.y;

                var earsGeometry = creatingEars(offset);
                creatureGeometry.merge(earsGeometry);

                offset.y =  offsetYMouth;
                var mouthGeometry = creatingMouth(offset);
                creatureGeometry.merge(mouthGeometry);

                creatureGeometry.computeFaceNormals();
                creatureGeometry.computeVertexNormals();
                return creatureGeometry;
            }


            function creatingNose(offset) {
                var coneUpDown = new THREE.ConeGeometry(1., 1., 3);
                coneUpDown.computeBoundingBox();
                coneUpDown.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI));
                coneUpDown.applyMatrix(new THREE.Matrix4().makeTranslation(0, -coneUpDown.boundingBox.max.y * .5, 0));                
                var coneDownUp = new THREE.ConeGeometry(1., 1., 3);
                coneDownUp.computeBoundingBox();
                coneDownUp.applyMatrix(new THREE.Matrix4().makeTranslation(0, coneDownUp.boundingBox.max.y, 0)); 
                var box = new THREE.BoxGeometry(.75, .75, .75);
                box.computeBoundingBox();
                box.applyMatrix(new THREE.Matrix4().makeTranslation(0, -box.boundingBox.max.y * .75, 0));
                var sphere = new THREE.SphereGeometry(.5, 12, 12);
                sphere.computeBoundingBox();
                sphere.applyMatrix(new THREE.Matrix4().makeTranslation(0, sphere.boundingBox.max.y * .5, 0));
                var cylinder =  new THREE.CylinderGeometry(.5, .5, 1.25, 12);
                var noseGeometries = [
                    coneUpDown,
                    coneDownUp,
                    box,
                    sphere,
                    cylinder
                ];
                var index = getRandom (0, noseGeometries.length-1);
                return noseGeometries[ index | 0 ];
            }


            function creatingEyes(offset) {
                var coneUpDown = new THREE.ConeGeometry( .5, .5, 3);
                coneUpDown.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI));
                var coneDownUp = new THREE.ConeGeometry( .5, .5, 3);
                var box = new THREE.BoxGeometry(.5, .5, .5);
                var sphere = new THREE.SphereGeometry( .25, 12, 12);
                var cylinderVertical =  new THREE.CylinderGeometry( .25, .25, .5, 12);
                var cylinderHorizontal = new THREE.CylinderGeometry( .25, .25, .5, 12);
                cylinderHorizontal.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI / 2.));
                var torus = new THREE.TorusGeometry( .25, .1, 20, 20);
                torus.computeBoundingBox();
                torus.applyMatrix(new THREE.Matrix4().makeTranslation(.0, -torus.boundingBox.max.y * .25, 0));
                var torusUp = new THREE.TorusGeometry( .25, .1, 20, 20, Math.PI );
                torusUp.computeBoundingBox();
                torusUp.applyMatrix(new THREE.Matrix4().makeTranslation(.0, -torusUp.boundingBox.max.y * .5, 0));
                var torusDown = new THREE.TorusGeometry( .25, .1, 20, 20, -Math.PI );
                torusDown.applyMatrix(new THREE.Matrix4().makeTranslation(.0, torusUp.boundingBox.max.y , 0));
                var torusHorizontal = new THREE.TorusGeometry( .25, .1, 20, 20);
                torusHorizontal.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), Math.PI/2));  

                var eyesGeometries = [
                    coneUpDown,
                    coneDownUp,
                    box,
                    sphere,
                    cylinderVertical,
                    cylinderHorizontal,
                    torus,
                    torusUp,
                    torusDown,
                    torusHorizontal
                ];
                var index = getRandom (0, eyesGeometries.length-1);
                var eyesGeometry = eyesGeometries[ index | 0 ];
                eyesGeometry.computeBoundingBox();
                var eyesGeometrySpecular = eyesGeometry.clone();
                eyesGeometrySpecular.computeBoundingBox();

                eyesGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(offset.x + eyesGeometry.boundingBox.max.x * .5, offset.y + eyesGeometry.boundingBox.max.y * 2., 0));

                eyesGeometrySpecular.applyMatrix(new THREE.Matrix4().makeTranslation(-offset.x - eyesGeometrySpecular.boundingBox.max.x * .5, offset.y +  eyesGeometrySpecular.boundingBox.max.y * 2., 0));

                eyesGeometry.merge(eyesGeometrySpecular);
                return eyesGeometry;
            }


            function creatingEars(offset) {
                var rotatedConeUp = new THREE.ConeGeometry(.25, 1.5, 4);
                rotatedConeUp.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), -Math.PI / 8.));

                var rotatedConeDown =  new THREE.ConeGeometry(.25, 2., 4);
                rotatedConeDown.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), -Math.PI / 4. * 3.));
                rotatedConeDown.computeBoundingBox();
                rotatedConeDown.applyMatrix(new THREE.Matrix4().makeTranslation(0, -rotatedConeDown.boundingBox.max.y, 0));

                var box = new THREE.BoxGeometry(.25, .25, .25);
                box.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI / 4.)); 

                var sphere = new THREE.SphereGeometry(.25, 12, 12);

                var cylinderUp = new THREE.CylinderGeometry(.125, .125, .75, 12);
                cylinderUp.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), -Math.PI / 8.));

                var cylinderDown = new THREE.CylinderGeometry(.125, .125, 1., 12);
                cylinderDown.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), -Math.PI / 4. * 3.));
                cylinderDown.computeBoundingBox();
                cylinderDown.applyMatrix(new THREE.Matrix4().makeTranslation(0, -cylinderDown.boundingBox.max.y, 0));

                var earsGeometries = [
                    rotatedConeUp,
                    rotatedConeDown,
                    box,
                    sphere,
                    cylinderUp,
                    cylinderDown
                ];
                var index = getRandom (0, earsGeometries.length-1);
                var earsGeometry = earsGeometries[ index | 0 ];
                earsGeometry.computeBoundingBox();
                var earsGeometrySpecular = earsGeometry.clone();
                earsGeometrySpecular.computeBoundingBox();

                earsGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(offset.x + earsGeometry.boundingBox.max.x*1.5, offset.y + earsGeometry.boundingBox.max.y, 0));
                if(index == 0 || index == 4){
                    earsGeometrySpecular.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI / 4.)); 
                    earsGeometrySpecular.applyMatrix(new THREE.Matrix4().makeTranslation(-offset.x - earsGeometrySpecular.boundingBox.max.x*1.5, offset.y +  earsGeometrySpecular.boundingBox.max.y, 0));
                }
                else if(index == 1 || index == 5){
                    earsGeometrySpecular.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI / 2. * 3)); 
                    earsGeometrySpecular.applyMatrix(new THREE.Matrix4().makeTranslation(-offset.x - earsGeometrySpecular.boundingBox.max.x*1.5, offset.y -earsGeometrySpecular.boundingBox.max.y, 0));
                }
                else if(index == 2 || index == 3){
                    earsGeometrySpecular.applyMatrix(new THREE.Matrix4().makeTranslation(-offset.x - earsGeometrySpecular.boundingBox.max.x*1.5, offset.y +earsGeometrySpecular.boundingBox.max.y, 0));
                }
                else{
                    earsGeometrySpecular.applyMatrix(new THREE.Matrix4().makeTranslation(-offset.x - earsGeometrySpecular.boundingBox.max.x*1.5, offset.y +earsGeometrySpecular.boundingBox.max.y, 0));
                }

                earsGeometry.merge(earsGeometrySpecular);
                return earsGeometry;
            }


            function creatingMouth(offset) {
                var coneUpDown = new THREE.ConeGeometry(2., 1., 25);
                coneUpDown.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI));              
                var coneDownUp = new THREE.ConeGeometry(2.25, 1.25, 25);
                var box = new THREE.BoxGeometry(2.5, 1., 2.5);
                box.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), Math.PI/4));
                var sphere = new THREE.SphereGeometry(1.25, 12, 12);

                var circle = new THREE.CircleGeometry( 1.5, 32 );
                circle.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), Math.PI));
                var halfSphere = new THREE.SphereGeometry(1.5, 12, 12, 0, Math.PI);
                halfSphere.merge(circle);
                halfSphere.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2.));
                halfSphere.computeFaceNormals();
                halfSphere.computeVertexNormals();

                var cylinder =  new THREE.CylinderGeometry(.25, .25, 3., 12);
                cylinder.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), Math.PI / 2.));

                var torusVertical = new THREE.TorusGeometry( 1., .15, 20, 20);

                var torusHorizontal = new THREE.TorusGeometry( 1.5, .25, 20, 20);
                torusHorizontal.applyMatrix(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), Math.PI/2));  

                var mouthGeometries = [
                    coneUpDown,
                    coneDownUp,
                    box,
                    sphere,
                    halfSphere,
                    cylinder,
                    torusVertical, 
                    torusHorizontal
                ];
                var index = getRandom (0, mouthGeometries.length-1);
                var mouthGeometry = mouthGeometries[ index | 0 ];
                mouthGeometry.computeBoundingBox();
                if(index == 0){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.y * 3.5, 0));
                }
                else if (index == 1){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.y * 2.5, 0));
                }
                else if (index == 2){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.y * 3.5, 0));
                }
                else if (index == 3){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.y * 1.5, 0));
                }
                else if (index == 4){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.x * .5, 0));
                }
                else if (index == 5){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.y * 6., 0));
                }
                else if(index == 6){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.x * 1.5, 0));
                }
                else if(index == 7){
                    mouthGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, offset.y - mouthGeometry.boundingBox.max.x * .75, 0));
                }
                return mouthGeometry;
            }


            function addStats() {
                stats = new Stats();
                document.getElementById( "content" ).appendChild( stats.dom );
            }


            function sendLocation() {
                var position = navigator.geolocation;
                var sendingData = 
                {
                    "latitude":     0,
                    "longitude":    0,
                    "altitude":     0
                };
                if (position) {
                    position.getCurrentPosition(setPosition, getErrLocation);
                    function setPosition(position) {
                        sendingData.latitude = position.coords.latitude;
                        sendingData.longitude = position.coords.longitude;
                        sendingData.altitude = position.coords.altitude;
                        sendingLocation();
                    }
                }
                else {
                    //Geolocation is not supported by this browser.
                    getErrLocation();
                }

                function getErrLocation() {
                    sendingData.latitude = getRandomArbitrary(-90.0,90.0);
                    sendingData.longitude = getRandomArbitrary(-180.0,180.0);
                    sendingData.altitude = getRandom(0,6000);
                    sendingLocation();
                }

                function sendingLocation() {
                    console.log("Sending location");
                    console.log(sendingData);
                    socket.emit("pushingData", sendingData);
                }
            }


            function submitData() {
                var sendingCreatures = 10;
                currentFrame=1;
                //socket.emit("broadcastData", sendingCreatures);
                //socket.emit("tweetData", sendingCreatures);
            }


            function socketInit() {
                socket = io.connect('http://localhost:3000');
                socket.on('broadcastData', refreshCreatures);
                //Initialize instances
                socket.on("initializeClient", initializeClient);
                socket.emit("initializeClient");
            }


            function refreshCreatures(data) {
                //todo refresh my creatures
                console.log("Receiving Data: " + data);
            }


            function initializeClient(data) {
                console.log("Initializing instances: " + data);
                initSketch(data);
            }


            function sendFrame() {
                socket.emit('render-frame', {
                        frame: currentFrame,
                        file: document.querySelector('canvas').toDataURL()
                });
            }


            function updateSize() {
                var width = canvas.clientWidth;
                var height = canvas.clientHeight;
                if ( canvas.width !== width || canvas.height != height ) 
                {
                    renderer.setSize( width, height, false );
                }
            }

            function animate() {
                render();
                stats.update();
                requestAnimationFrame( animate );
            }

            function render() {
                updateSize();

                renderer.setClearColor( 0xffffff );
                renderer.setScissorTest( false );
                renderer.clear();

                renderer.setClearColor( 0xe0e0e0 );
                renderer.setScissorTest( true );

                scenes.forEach( function( scene ) {

                    // so something moves
                    scene.children[0].rotation.y = Date.now() * 0.0005;

                    // get the element that is a place holder for where we want to
                    // draw the scene
                    var element = scene.userData.element;

                    // get its position relative to the page's viewport
                    var rect = element.getBoundingClientRect();

                    // check if it's offscreen. If so skip it
                    if ( rect.bottom < 0 || rect.top  > renderer.domElement.clientHeight ||
                         rect.right  < 0 || rect.left > renderer.domElement.clientWidth ) {

                        return;  // it's off screen

                    }

                    // set the viewport
                    var width  = rect.right - rect.left;
                    var height = rect.bottom - rect.top;
                    var left   = rect.left;
                    var bottom = renderer.domElement.clientHeight - rect.bottom;

                    renderer.setViewport( left, bottom, width, height );
                    renderer.setScissor( left, bottom, width, height );

                    var camera = scene.userData.camera;

                    //camera.aspect = width / height; // not changing in this example
                    //camera.updateProjectionMatrix();

                    //scene.userData.controls.update();

                    renderer.render( scene, camera );


                } );

                if( currentFrame>=1 && currentFrame<=frameLimit ) {
                    sendFrame();
                    currentFrame++;
                }
            }
        </script>
    </body>
</html>